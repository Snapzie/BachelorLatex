\section{Building a repository}
We have already seen an overview of what has been created, but we will now go into details about how we got here. As already discussed in the actor model section '\nameref{AMRelation}' our driving force for the project has been to examine four cases relating the actor model to the CLS, namely:
\begin{enumerate}
	\item Synthesizing objects with timers. This was primarily aimed to be accomplished in the player object through the use of different abilities.
	\item Disposing timers. As both the monsters and the boss has recurring timers and they both can be killed, it is important that we ensure their timers are disposed correctly. If not we might end up with 'invisible' enemies hitting players throughout their adventure.
	\item Synthesizing an object which spawns actors. This is accomplished in the boss with its baseline ability to spawn small monsters in the room with it.
	\item Handling a list of arguments in our meta language. We see this in the weather effects in the rooms where a random weather effect from a given list can be chosen and will have an effect on the players each time they change room.
\end{enumerate}
Our overall goal with this project has been to examine if it is possible to synthesize actor code with the use of the CLS and we found that the four cases above would not be comprehensive but we see the first three to be common tasks performed when coding with the actor model, and the last we foresee to be a common way to program with meta languages when using the CLS. We therefore see the four cases as a good indication of whether it is possible synthesize actor code on a larger scale rather than a definitive answer to the CLS being a perfect tool to synthesize actor code.\\

Throughout development we found that the coupling between the oldest objects we coded and the newest grew bigger and bigger. This is a tendency we think is rather common in software development (and perhaps also logically) if developers are not careful about their designs and encapsulation. This might also have been an indication that we should have taken a step back and tried to modularize our code more than we have. The fact that the coupling grew with each addition of features made decomposition harder, and finding meaningful decompositions hard as we might just have wanted to change a few lines of code somewhere. In this rather small project we have managed to work around the coupling, at least to a satisfying extent. However, this might not be the case in bigger projects, and thus our first point to stress is that actors should truly be isolated to allow for good decomposition. To achieve clean repositories we need close to no coupling between objects, and thus good design of programs are essential for decomposition. \todo{Point for conclusion here.}

\input{Sections/Decomposition/Player}
\input{Sections/Decomposition/Boss}
\subsection{Room}
\begin{itemize}
	\item Dependency injection of weather effect objects.
	\item Strategy pattern.
	\item writing 4 kindings, one for each weather
	\item 'abuse' strings and make it dynamic
\end{itemize}

\input{Sections/Decomposition/Components}

\subsection{Future work}
In future work with the CLS and Orleans we cannot put enough emphasis on how important a good solid design is. When we began learning about the CLS we thought it would eliminate the need for dependency injection, we just replace code so why make a socket for it? After working on this project we now understand the importance and we understand that the CLS does not replace any already existing software engineering principles, on the contrary, using the CLS makes it much more important to follow them. Both the CLS and Orleans strive to work with encapsulated and isolated code which has no to little coupling with other entities, and so they both seem and feel to be a great match together, also for future projects.