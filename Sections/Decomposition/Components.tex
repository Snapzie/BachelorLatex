\subsection{Good decomposition}
One can now raise the question, did we achieve good decomposition? To answer that, we would need to look at what makes a good component. This has been a difficult task to answer, as it has been hard to find literature that answers that question. The closest we have got is \cite{Components}, but the focus can be seen to be on a bit higher level than our decomposition. \cite{Components} gives the impression that a component is a collection of code wrapped in a well defined and well documented interface. The focus is on how the component will be communicating with the other classes of the system through its interface, and so there is great emphasis on the design. We can look at this from two angles. We can look at our components as the actors of our system, the player, room, monsters and boss. Here we see encapsulated units with some dependencies on each other and well defined interfaces for the interaction they have with each other. We here have some units which could be reused in another game which is structured the same way. However, we can also look at each of the actors and decompose them. It is here it gets a little uglier and many of the issues described in the previous subsections arise. When we decomposed the actors we did not create a standard for what the components should be and thus we did not create interfaces for them. We have already discussed when it would have made sense and when not, but not doing it makes it hard to reuse in other projects, and so looking at our individual combinators, its not a lot of them that are reusable. We did not really intend each combinator to be reusable by itself as our goal was to combinate the actors. Our goal was to create interesting variations which were not too similar, and we believe that we succeeded there. However, depending on which angle we look at our decomposition, we get different results. Although less coupling and less dependency on the room would be preferable, we still feel they are encapsulated and independent. It is hard to keep both the single responsibility principle and have no coupling, and so we feel we have a good trade off. If we look at the system as a whole, the actors becomes some of the components and although some design decisions have made it hard to extend them we see them as decent components, and thus we have achieved somewhat good decomposition.\\
Had our goal been to create the components for our actors, we would probably not have been combinating our actors as a whole, but instead creating smaller classes like a 'PlayerAbility' class which we would then create different methods for. The end goal would be the same, a player with an ability, but here all the combinators would be reusable. It is thus important to distinguish the two viewpoints from each other when we evaluate our decomposition as they yield two very different results. We can however compare the two approaches, and conclude that we have probably chosen the wrong approach due to both simplicity and the amount of combinators which could be made reusable.