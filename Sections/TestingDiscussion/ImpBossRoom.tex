\subsubsection{Room \& Boss Unit Tests}
Since neither room test nor boss tests have this overlap between multiple variables, it means that these tests are much simpler to implement. Let us start by looking at the boss tests. \\
\\
Boss tests are rather simple, as they only rely on the variation of the boss' abilities. Since boss does not take player or room into account, it makes for an easy synthesis. In essence, we only need one combinator for each of the boss' abilities for testing. Semantically, these combinators are of type \textit{'bossTest} that takes a kinding to specify which combinator to be chosen for synthesis. This means that boss tests can be described as: \textit{string $\cap$ bossTest $\to$ MyResult $\cap$ bossTestAbility}. However, this does not completely describe boss tests. \\
The boss can have three different abilities: heal, DR (damage reduction) and none. The interesting ability here is none. None does not specify that the boss has no abilities, but instead it specifies that the boss is not present in this variation of the game. This means that the essential tests, that are independent of the boss' abilities, are no longer necessary and hence should not be included. This means in the case of no boss we do not need our \textit{'bossTest} to specify the tests that should be included based on abilities. This means we need a combinator that creates an empty file, such that no tests of the boss are present. This way, in the case where boss is nonexistent, boss tests can be described as: \textit{MyResult $\cap$ bossTestAbility}. \todo{Not sure how to show void $\to$ something. It would be intersected by 'none no?} \\
As the only factor of how the boss tests vary depends on the boss' abilities, tests of new abilities could easily be integrated as long as these tests are on a function level, such that this structure of \textit{'bossTest} can be kept. By doing this, scaling of the tests, based on new inclusion of abilities, seem feasible as the combinators do not intertwine and affect each other, a new combinator can simply be added for a given new ability. %This also reinforces the idea that loose coupling makes for good combinators and thus this kind of unit testing is great in use of the CLS.
\\ \\
As the weather has been tested as its own class during unit testing, the room only need to take boss into account when being combinated. Other than the essential room tests, the only tests that vary from variation to variation is the boss part of room. This means that our semantic target for room only have two real cases, a \textit{'roomTestFile} with \textit{'boss} or with \textit{'noBoss}. Besides this, room is largely similiar to the boss tests in structure, where we have the semantic type \textit{'roomTest} that specifies a combinator with or without a boss. Therefore we can describe room tests as: \textit{string $\cap$ 'roomTest $\to$ MyResult $\cap$ 'roomTestFile}. 