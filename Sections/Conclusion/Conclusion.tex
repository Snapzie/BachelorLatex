\section{Conclusion}
\subsection{Synthesizing actor code}
Our driving force has been to:
\begin{enumerate}
	\item Synthesizing objects with timers.
	\item Synthesizing objects which disposes timers.
	\item Synthesizing an object which spawns actors.
	\item Defining a list of arguments in our meta language which then effects our synthesis. 
\end{enumerate}
We began our discussion of how we had build our repository by looking at how the player got extended with abilities which used timers to create a cooldown for the abilities. As we have been successful in synthesizing the player, we meet our first goal. We then looked into how we could dispose the recurring ability timers from the monsters and boss. We here found that the safest way of doing so, was to leave the \textit{kill} methods unsynthesized to guarantee that the monsters' and boss' lifecycle would always end by disposing the timers at the end of their \textit{kill} method. We thus conclude that we meet our second goal and that critical code is best left unsynthesized. The boss always have the ability to spawn small monsters to help him fight. This is done by initializing a new actor, and so we meet goal number three. Looking at the room we see it is possible to define a combination of four weathers in our metalanguage and have these defined weathers added to the game variation. We have thus also succeeded in meeting our fourth goal.\\
When we started working with the CLS, we thought it would replace the need for dependency injection. However, as we conclude our work, we realize that to achieve clean repositories, we need close to no coupling between objects, and thus good design and encapsulation. Dependency injection helps with encapsulation and to limit coupling, and so, when working with the CLS it is important to understand that it does not replace any software engineering principles, on the contrary it is even more important to follow them as otherwise the decompositions gets messy.\\
Did we achieve good decomposition? We can look at our decomposition from two angles. First we can see our decomposition as decomposing the game into the actors. But we can also take a step further and look at how the actors can be decomposed. When looking form the second perspective our components are not really clean. They do not conform to interfaces, they are \textit{very} specific and they lack purpose and meaning as we can not see the whole picture. As we have focused on synthesizing the actors, we choose to conclude on the basis of the first perspective. This does not mean it was the best solution, as if we had focused on reusability and to create standards which the smaller components could conform to, we would probably have achieved better results. We choose to evaluate our work on the first perspective as that has been our perspective. What we see is not flawless decomposition where each component is completely isolated, but we achieved components which conforms to interfaces and to some extent can be reused and extended further upon. To this we conclude that it is more than possible to synthesize actor code and that it seems both Orleans and the CLS strive to work with encapsulated and isolated code which has no to little coupling with other entities.

\subsection{Synthesizing Tests}
Let us reiterate our goals when it came to testing, as introduced in the \nameref{intro}. We stated that our goal here was split into two parts. The first part was testing of our program, which includes the initial application as well as the different game variations we could create. The other part was the synthesis of the code, meaning creating combinators in our repository, such that when synthesizing a variation the corresponding tests, meaning the tests specific to that variation, would be synthesized alongside the game. Thus, when synthesizing a variation of the game, you would immediately be able to run the tests and ensure that the synthesized variation was indeed correct. \\
In our discussion of testing we went over the implementation of our tests, both as tests themselves and as combinator pieces in the repository. We also went over how the implementation and obstacles affected our goals and in the section \nameref{summingUp}, we looked at what this meant for our goals and how well our testing in the project conformed to those. There, we looked at how the obstacles obstructed us from during complete testing of the application and we came to the conclusion that this meant somewhat failure to the first part of the goal, that is the testing itself of the initial program, as well as the testing of variations. This is due to failure in some of the essential tests, those that would belong to the initial program, and failure in some of the variation specific tests. The variation specific tests, however, only failed when it came to the room tests, as explained in the subsection '\nameref{roomTestsWeather}'. \\
The second part of the goal was the synthesis and use of the CLS when it came to testing of the actor code. As we went over in the conclusion when it came to synthesis of actor code itself, the major problem was high coupling between the grains. This specific problem was not present in synthesis of the tests, as the tests themselves are somewhat contained, meaning that combination and synthesis always happened on a method level basis. However, we did run into an obstacle with coupling when it came to tests that depended on specific variations within the different grains, that is tests that for instance depend on a specific player ability as well as a specific boss ability. We went over this in the subsection '\nameref{playerUnit}', and while the structure of those combinators were not optimal, it was indeed possible. The rest of the tests to be decomposed did not have this overlap and this, along with the structure of synthesizing on a method level basis, made decomposing and combination of tests very straightforward and simple. With this, we can conclude that, while the tests themselves were somewhat insufficient, this project has showcased that due to their structure, tests work excellently with the CLS. This means tests would make great additions for other synthesized code as to check for validity of the synthesis, as long as you are careful when it comes to the overlapping issue mentioned.
