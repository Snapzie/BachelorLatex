\section{Conclusion}
\subsection{Synthesizing actor code}
Our driving force has been to:
\begin{enumerate}
	\item Synthesizing objects with timers.
	\item Synthesizing objects which disposes timers.
	\item Synthesizing an object which spawns actors.
	\item Defining a list of arguments in our meta language which then effects our synthesis. 
\end{enumerate}
We began our discussion of how we had build our repository by looking at how the player got extended with abilities which used timers to create a cooldown for the abilities. As we have been successful in synthesizing the player, we meet our first goal. We then looked into how we could dispose the recurring ability timers from the monsters and boss. We here found that the safest way of doing so, was to leave the \textit{kill} methods unsynthesized to guarantee that the monsters' and boss' lifecycle would always end by disposing the timers at the end of their \textit{kill} method. We thus conclude that we meet our second goal and that critical code is best left unsynthesized. The boss always have the ability to spawn small monsters to help him fight. This is done by initializing a new actor, and so we meet goal number three. Looking at the room we see it is possible to define a combination of four weathers in our metalanguage and have these defined weathers added to the game variation. We have thus also succeeded in meeting our fourth goal.\\
When we started working with the CLS, we thought it would replace the need for dependency injection. However, as we conclude our work, we realize that to achieve clean repositories, we need close to no coupling between objects, and thus good design and encapsulation. Dependency injection helps with encapsulation and to limit coupling, and so, when working with the CLS it is important to understand that it does not replace any software engineering principles, on the contrary it is even more important to follow them as otherwise the decompositions gets messy.\\
Did we achieve good decomposition? We can look at our decomposition from two angles. First we can see our decomposition as decomposing the game into the actors. But we can also take a step further and look at how the actors can be decomposed. When looking form the second perspective our components are not really clean. They do not conform to interfaces, they are \textit{very} specific and they lack purpose and meaning as we can not see the whole picture. As we have focused on synthesizing the actors, we choose to conclude on the basis of the first perspective. This does not mean it was the best solution, as if we had focused on reusability and to create standards which the smaller components could conform to, we would probably have achieved better results. We choose to evaluate our work on the first perspective as that has been our perspective. What we see is not flawless decomposition where each component is completely isolated, but we achieved components which conforms to interfaces and to some extent can be reused and extended further upon. To this we conclude that it is more than possible to synthesize actor code and that it seems both Orleans and the CLS strive to work with encapsulated and isolated code which has no to little coupling with other entities.