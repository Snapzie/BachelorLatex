\section{Abstract}
In an attempt to synthesize actor code and tests, we have been looking into the Combinatory Logic Synthesizer (CLS) a type based tool to automatically compose larger systems from a repository of code components. Our work began by identifying four key areas that could illustrate the compatibility of actor code and the CLS. Namely we look into synthesizing code with timers, synthesizing code where we dispose timers, synthesizing code which creates other actors and defining a list of parameters in a metalanguage which have direct effect on our synthesis. Our results show we meet all of these key areas. When answering whether we obtained good decomposition in the process, we can view the decomposition from two perspectives. When looking from the perspective we had during our work, we end with overall decently encapsulated and isolated components, although they do suffer from some extendability issues, mainly due to coupling between the actors. And so we conclude it is more than possible to synthesize actor code and that it seems the CLS works well with actor code.\\
Secondly, our objective has also been testing, both in the sense of testing our solution, as well as investigating the compatibility of testing and the CLS. We want to do this, as synthesizing tests alongside other code can be used to check the validity of the synthesized code. Our goal here was to test our initial application and synthesize tests specific to product line members. However, due to our implementation making testing difficult, our tests are incomprehensive. We managed to synthesize our test suites, such that tests were tailored to specific product line members. However, tests that depended on multiple variation factors proved more difficult to decompose and synthesize, due to added information needed in the combinators. Still, the tests' decomposition was mostly straightforward and proved to make excellent combinators for synthesis.

\section{Introduction}\label{intro}
In this thesis we have extended upon a sandbox-like demo project from Microsoft \cite{AdventureGame} which resembles an adventure game and is written in a distributed fashion with Orleans. We have then decomposed it into a code repository with the  purpose of using the Combinatory Logic Synthesizer, a type based tool to automatically compose larger systems from a repository of code components, to create different variations of the game based on definitions written in a metalanguage. Our goal has been to synthesize code with timers, synthesizing code where we dispose timers, synthesizing code where we create other actors and to be able to define a list of parameters in our metalanguage and then synthesize code where only the defined parameters are present in the game variation. Our goal has also been to test our application, both as the initial program as well as the combinated variations of the game. This means synthesizing tests in the same way as our code, such that a given variation has tests alongside the program specific to that variation. \\
We will begin by looking at the theory behind the actor model and Orleans, then we will move to the theory of the Combinatory Logic Synthesizer and how it works. After that we will look into more detail about the extensions we have made to the Microsoft project. We will then look into the design decisions about decomposing the code, the issues we faced and what improvements we could have made. We will also look into what makes a good component and ask ourselves if we have achieved good decomposition. 
Then we will look into the relevant theory of testing software, followed by a deeper dive into our testing, meaning the tests themselves alongside the tests as combinators in the CLS. We will be discussing our implementation and looking at some of the obstacles we faced during our process of creating tests. We will then comment on our results and lastly make our conclusions.